import { unref as I, onMounted as ve, nextTick as be, onUnmounted as De, getCurrentInstance as q, getCurrentScope as Se, onScopeDispose as we, customRef as xe, onUpdated as Ce, watch as O, reactive as re, ref as ae, effectScope as se, toRefs as ie, computed as ee, isVue3 as X, defineComponent as ue, h as R } from "vue-demi";
function le(e) {
  return Se() ? (we(e), !0) : !1;
}
function B() {
  const e = /* @__PURE__ */ new Set(), o = (t) => {
    e.delete(t);
  };
  return {
    on: (t) => {
      e.add(t);
      const s = () => o(t);
      return le(s), {
        off: s
      };
    },
    off: o,
    trigger: (...t) => Promise.all(Array.from(e).map((s) => s(...t)))
  };
}
function v(e, o) {
  return o == null ? I(e) : I(e)[o];
}
function ce(e) {
  return typeof e == "function" ? e() : I(e);
}
const Te = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Ne = Object.prototype.toString, Pe = (e) => Ne.call(e) === "[object Object]", Ee = () => {
};
function fe(e) {
  return q();
}
function K(e, o = !0, n) {
  fe() ? ve(e, n) : o ? e() : be(e);
}
function Me(e, o) {
  fe() && De(e, o);
}
function Q(e) {
  var o;
  const n = ce(e);
  return (o = n == null ? void 0 : n.$el) != null ? o : n;
}
const $e = Te ? window : void 0;
function A(...e) {
  let o, n, r, t;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, r, t] = e, o = $e) : [o, n, r, t] = e, !o)
    return Ee;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], c = () => {
    s.forEach((m) => m()), s.length = 0;
  }, h = (m, x, D, T) => (m.addEventListener(x, D, T), () => m.removeEventListener(x, D, T)), g = O(
    () => [Q(o), ce(t)],
    ([m, x]) => {
      if (c(), !m)
        return;
      const D = Pe(x) ? { ...x } : x;
      s.push(
        ...n.flatMap((T) => r.map((U) => h(m, T, U, D)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    g(), c();
  };
  return le(d), d;
}
function ge(e, o = null) {
  const n = q();
  let r = () => {
  };
  const t = xe((s, c) => (r = c, {
    get() {
      var h, g;
      return s(), (g = (h = n == null ? void 0 : n.proxy) == null ? void 0 : h.$refs[e]) != null ? g : o;
    },
    set() {
    }
  }));
  return K(r), Ce(r), t;
}
function _(e, o) {
  for (let n = 0, r = e.length; n < r; n++)
    if (o.apply(o, [e[n], n, e]))
      return e[n];
}
function J(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Function]";
}
function de(e) {
  return !!("targetTouches" in e && e.targetTouches && "changedTouches" in e && e.changedTouches);
}
function H(e) {
  return !Number.isNaN(e);
}
function b(e) {
  return Number.parseInt(e, 10);
}
const V = ["Moz", "Webkit", "O", "ms"];
function Le(e = "transform") {
  var n, r;
  if (typeof window > "u")
    return "";
  const o = (r = (n = window.document) == null ? void 0 : n.documentElement) == null ? void 0 : r.style;
  if (!o || e in o)
    return "";
  for (let t = 0; t < V.length; t++)
    if (pe(e, V[t]) in o)
      return V[t];
  return "";
}
function pe(e, o) {
  return o ? `${o}${je(e)}` : e;
}
function je(e) {
  let o = "", n = !0;
  for (let r = 0; r < e.length; r++)
    n ? (o += e[r].toUpperCase(), n = !1) : e[r] === "-" ? n = !0 : o += e[r];
  return o;
}
const Be = Le();
let Y = "";
function Oe(e, o) {
  return Y || (Y = _(
    ["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"],
    (n) => J(e[n])
  )), J(e[Y]) ? e[Y](o) : !1;
}
function te(e, o, n) {
  let r = e;
  do {
    if (Oe(r, o))
      return !0;
    if (r === n)
      return !1;
    r = r.parentNode;
  } while (r);
  return !1;
}
function ne(e, o, n, r) {
  if (!e)
    return;
  const t = { capture: !0, ...r };
  e.addEventListener ? e.addEventListener(o, n, t) : e[`on${o}`] = n;
}
function oe(e, o, n, r) {
  if (!e)
    return;
  const t = { capture: !0, ...r };
  e.removeEventListener ? e.removeEventListener(o, n, t) : e[`on${o}`] = null;
}
function Ue(e) {
  var r;
  let o = e.clientHeight;
  const n = (r = e.ownerDocument.defaultView) == null ? void 0 : r.getComputedStyle(e);
  return o += b(n == null ? void 0 : n.borderTopWidth), o += b(n == null ? void 0 : n.borderBottomWidth), o;
}
function ke(e) {
  var r;
  let o = e.clientWidth;
  const n = (r = e.ownerDocument.defaultView) == null ? void 0 : r.getComputedStyle(e);
  return o += b(n == null ? void 0 : n.borderLeftWidth), o += b(n == null ? void 0 : n.borderRightWidth), o;
}
function Fe(e, o) {
  return _(e.targetTouches, (n) => o === n.identifier) || _(e.changedTouches, (n) => o === n.identifier);
}
function Ae(e) {
  if (de(e)) {
    if (e.targetTouches[0])
      return e.targetTouches[0].identifier;
    if (e.changedTouches[0])
      return e.changedTouches[0].identifier;
  }
}
function He(e) {
  var r;
  let o = e.clientHeight;
  const n = (r = e.ownerDocument.defaultView) == null ? void 0 : r.getComputedStyle(e);
  return o -= b(n == null ? void 0 : n.paddingTop), o -= b(n == null ? void 0 : n.paddingBottom), o;
}
function Ye(e) {
  var r;
  let o = e.clientWidth;
  const n = (r = e.ownerDocument.defaultView) == null ? void 0 : r.getComputedStyle(e);
  return o -= b(n == null ? void 0 : n.paddingLeft), o -= b(n == null ? void 0 : n.paddingRight), o;
}
function Xe(e, o, n) {
  const t = o === o.ownerDocument.body ? { left: 0, top: 0 } : o.getBoundingClientRect(), s = (e.clientX + o.scrollLeft - t.left) / n, c = (e.clientY + o.scrollTop - t.top) / n;
  return { x: s, y: c };
}
function Re(e, o) {
  const n = me(e, "px", o);
  return { [pe("transform", Be)]: n };
}
function Ve(e, o) {
  return me(e, "", o);
}
function me({ x: e, y: o }, n = "px", r) {
  let t = `translate(${Math.round(e)}${n},${Math.round(o)}${n})`;
  if (r) {
    const s = `${typeof r.x == "string" ? r.x : Math.round(r.x) + n}`, c = `${typeof r.y == "string" ? r.y : Math.round(r.y) + n}`;
    t = `translate(${s}, ${c})${t}`;
  }
  return t;
}
function We(e) {
  if (!e)
    return;
  if (!e.getElementById("revue-draggable-style-el")) {
    const n = e.createElement("style");
    n.type = "text/css", n.id = "revue-draggable-style-el", n.innerHTML = `.revue-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, n.innerHTML += `.revue-draggable-transparent-selection *::selection {all: inherit;}
`, e.getElementsByTagName("head")[0].appendChild(n);
  }
  e.body && ze(e.body, "revue-draggable-transparent-selection");
}
function Ge(e) {
  if (e)
    try {
      e.body && Ie(e.body, "revue-draggable-transparent-selection");
      const o = (e.defaultView || window).getSelection();
      o && o.type !== "Caret" && o.removeAllRanges();
    } catch {
    }
}
function ze(e, o) {
  e.classList ? e.classList.add(o) : e.className.match(new RegExp(`(?:^|\\s)${o}(?!\\S)`)) || (e.className += ` ${o}`);
}
function Ie(e, o) {
  e.classList ? e.classList.remove(o) : e.className = e.className.replace(new RegExp(`(?:^|\\s)${o}(?!\\S)`, "g"), "");
}
function _e({
  bounds: e,
  x: o,
  y: n,
  node: r
}) {
  if (!e)
    return [o, n];
  if (e = typeof e == "string" ? e : Qe(e), typeof e == "string") {
    const { ownerDocument: t } = r, s = t.defaultView, c = e === "parent" ? r.parentNode : t.querySelector(e);
    if (!(s && c instanceof s.HTMLElement))
      throw new Error(`Bounds selector "${e}" could not find an element.`);
    const h = s.getComputedStyle(r), g = s.getComputedStyle(c), d = "offsetLeft" in r ? r.offsetLeft : 0, m = "offsetTop" in r ? r.offsetTop : 0;
    e = {
      left: -(d - c.offsetLeft) + b(g.paddingLeft) + b(h.marginLeft),
      top: -(m - c.offsetTop) + b(g.paddingTop) + b(h.marginTop),
      right: Ye(c) - ke(r) - d + b(g.paddingRight) - b(h.marginRight),
      bottom: He(c) - Ue(r) - m + b(g.paddingBottom) - b(h.marginBottom)
    };
  }
  return H(e.right) && (o = Math.min(o, e.right)), H(e.bottom) && (n = Math.min(n, e.bottom)), H(e.left) && (o = Math.max(o, e.left)), H(e.top) && (n = Math.max(n, e.top)), [o, n];
}
function Je(e, o, n) {
  const r = Math.round(o / e[0]) * e[0], t = Math.round(n / e[1]) * e[1];
  return [r, t];
}
function qe(e) {
  return e === "both" || e === "x";
}
function Ke(e) {
  return e === "both" || e === "y";
}
function W({
  e,
  touch: o,
  node: n,
  offsetContainer: r,
  scale: t
}) {
  const s = typeof o == "number" && de(e) ? Fe(e, o) : null;
  if (typeof o == "number" && !s)
    return null;
  const c = r || "offsetParent" in n && n.offsetParent || n.ownerDocument.body;
  return Xe(s || e, c, t);
}
function G({
  node: e,
  x: o,
  y: n,
  lastX: r,
  lastY: t
}) {
  return Number.isNaN(r) ? {
    node: e,
    deltaX: 0,
    deltaY: 0,
    lastX: o,
    lastY: n,
    x: o,
    y: n
  } : {
    node: e,
    deltaX: o - r,
    deltaY: n - t,
    lastX: r,
    lastY: t,
    x: o,
    y: n
  };
}
function z({ x: e, y: o, data: n }) {
  return {
    node: n.node,
    x: e + n.deltaX,
    y: o + n.deltaY,
    deltaX: n.deltaX,
    deltaY: n.deltaY,
    lastX: e,
    lastY: o
  };
}
function Qe(e) {
  return {
    left: e.left,
    top: e.top,
    right: e.right,
    bottom: e.bottom
  };
}
function j(...e) {
  typeof process < "u" && process.env.DRAGGABLE_DEBUG && console.log(...e);
}
const ye = (e) => {
  const o = re(
    Object.assign(
      {
        allowAnyClick: !1,
        cancel: "",
        handle: "",
        disabled: !1,
        enableUserSelectHack: !0,
        enableTransformFix: !1,
        offsetParent: void 0,
        grid: void 0,
        start: () => {
        },
        move: () => {
        },
        stop: () => {
        },
        mouseDown: () => {
        },
        position: void 0,
        currentPosition: { x: Number.NaN, y: Number.NaN },
        positionOffset: void 0,
        scale: 1,
        axis: "both",
        defaultClassNameDragging: "revue-draggable-dragging",
        defaultClassNameDragged: "revue-draggable-dragged",
        defaultClassName: "revue-draggable",
        defaultPosition: { x: 0, y: 0 },
        bounds: !1,
        dragging: !1,
        dragged: !1,
        prevPropsPosition: { x: 0, y: 0 },
        isElementSVG: !1,
        update: !0
      },
      e
    )
  );
  return () => o;
}, N = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let L = N.mouse;
function Z(e, o, n) {
  const r = ae(), t = J(o) ? o() : ye(o)(), s = re({ x: Number.NaN, y: Number.NaN }), c = B(), h = B(), g = B();
  return se().run(() => {
    O(
      () => t,
      (u) => {
        u.position && !u.dragging && (s.x = Number.NaN, s.y = Number.NaN);
      }
    );
    const m = (u) => {
      var l;
      const y = v(r);
      if (!t.allowAnyClick && "button" in u && u.button !== 0)
        return !1;
      if (!y || !y.ownerDocument || !y.ownerDocument.body)
        throw new Error("No ref element found on DragStart!");
      const { ownerDocument: S } = y;
      if (t.disabled || !(S.defaultView && u.target !== null && u.target instanceof S.defaultView.Node) || t.handle && !te(u.target, t.handle, y) || t.cancel && te(u.target, t.cancel, y))
        return;
      u.type === "touchstart" && u.preventDefault(), t.touch = Ae(u);
      const C = W({
        e: u,
        touch: t.touch,
        node: y,
        offsetContainer: t.offsetParent,
        scale: t.scale
      });
      if (C == null)
        return;
      const { x: w, y: a } = C, i = G({
        node: y,
        x: w,
        y: a,
        lastX: s.x,
        lastY: s.y
      });
      j("DraggableCore: handleDragStart: %j", i);
      const f = n ? !0 : (l = t.start) == null ? void 0 : l.call(t, u, i);
      if (c.trigger({ event: u, data: i }), (f || t.update) === !1)
        return !1;
      t.enableUserSelectHack && We(S), t.dragging = !0, s.x = w, s.y = a, ne(S, L.move, x), ne(S, L.stop, D);
    }, x = (u) => {
      var S;
      const y = v(r);
      if (y) {
        const P = W({
          e: u,
          touch: t.touch,
          node: y,
          offsetContainer: t.offsetParent,
          scale: t.scale
        });
        if (P == null)
          return;
        let { x: C, y: w } = P;
        const a = t.grid;
        if (a && Array.isArray(a)) {
          let l = C - s.x, p = w - s.y;
          if ([l, p] = Je(a, l, p), !l && !p)
            return;
          C = s.x + l, w = s.y + p;
        }
        const i = G({
          node: y,
          x: C,
          y: w,
          lastX: s.x,
          lastY: s.y
        });
        j("DraggableCore: handleDrag: %j", i);
        const f = n ? !0 : (S = t.move) == null ? void 0 : S.call(t, u, i);
        if (h.trigger({ event: u, data: i }), (f || t.update) === !1) {
          try {
            D(new MouseEvent("mouseup"));
          } catch {
            const p = document.createEvent("MouseEvents");
            p.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), D(p);
          }
          return;
        }
        s.x = C, s.y = w;
      }
    }, D = (u) => {
      var S;
      const y = v(r);
      if (t.dragging && y) {
        const P = W({
          e: u,
          touch: t.touch,
          node: y,
          offsetContainer: t.offsetParent,
          scale: t.scale
        });
        if (P == null)
          return;
        const { x: C, y: w } = P, a = G({
          node: y,
          x: C,
          y: w,
          lastX: s.x,
          lastY: s.y
        }), i = n ? !0 : (S = t.stop) == null ? void 0 : S.call(t, u, a);
        if (g.trigger({ event: u, data: a }), (i || t.update) === !1)
          return !1;
        t.enableUserSelectHack && Ge(y.ownerDocument), j("DraggableCore: handleDragStop: %j", a), t.dragging = !1, j("DraggableCore: Removing handlers"), oe(y.ownerDocument, L.move, x), oe(y.ownerDocument, L.stop, D);
      }
    }, T = (u) => {
      var y;
      if (L = N.mouse, (y = t.mouseDown) == null || y.call(t, u), u.which != 3)
        return m(u);
    }, U = (u) => (L = N.mouse, D(u)), k = (u) => (L = N.touch, m(u)), F = (u) => (L = N.touch, D(u));
    K(() => {
      if (r.value = Q(e), !r.value) {
        console.error("You are trying to use <DraggableCore> without passing a valid node reference. Canceling initialization.");
        return;
      }
      A(v(r), N.touch.start, k, { passive: !1 }), A(v(r), N.touch.stop, F), A(v(r), N.mouse.start, T), A(v(r), N.mouse.stop, U);
    });
  }), {
    ...ie(t),
    state: t,
    onDragStart: c.on,
    onDrag: h.on,
    onDragStop: g.on
  };
}
function he(e, o) {
  const n = ae(), r = ye(o), t = r(), s = B(), c = B(), h = B(), g = B();
  return se().run(() => {
    const m = (a, i) => {
      j("Draggable: onDragStart: %j", i);
      const f = z({
        data: i,
        ...t.currentPosition
      }), l = t.start ? t.start(a, f) : t.update;
      if (s.trigger({ event: a, data: f }), typeof l < "u" && !l)
        return !1;
      t.dragging = !0, t.dragged = !0;
    }, x = (a, i) => {
      if (!t.dragging)
        return !1;
      j("Draggable: onDrag: %j", i);
      const f = z({
        data: i,
        ...t.currentPosition
      }), l = {
        x: f.x,
        y: f.y
      };
      if (t.bounds) {
        const [E, M] = _e({
          bounds: t.bounds,
          x: l.x,
          y: l.y,
          node: i.node
        });
        l.x = E, l.y = M, f.x = l.x, f.y = l.y, f.deltaX = l.x - t.currentPosition.x, f.deltaY = l.y - t.currentPosition.y;
      }
      const p = t.move ? t.move(a, f) : t.update;
      if (c.trigger({ event: a, data: f }), typeof p < "u" && !p)
        return !1;
      t.currentPosition = l, F();
    }, D = (a, i) => {
      if (!t.dragging)
        return !1;
      const f = z({
        data: i,
        ...t.currentPosition
      }), l = t.stop ? t.stop(a, f) : t.update;
      if (h.trigger({ event: a, data: f }), typeof l < "u" && !l)
        return !1;
      j("Draggable: onDragStop: %j", i), t.enableTransformFix && T(), t.dragging = !1;
    }, T = () => {
      var l, p;
      const a = v(n);
      if (!a)
        return;
      a.style.transform = "", a.style.left = "", a.style.top = "", a.style.position = "relative";
      const { x: i, y: f } = k.value;
      a.style.left = `${Math.round(b((l = t.positionOffset) == null ? void 0 : l.x) || 0) + Math.round(Number(i))}px`, a.style.top = `${Math.round(b((p = t.positionOffset) == null ? void 0 : p.y) || 0) + Math.round(Number(f))}px`;
    }, U = () => {
      const a = v(n);
      a && (a.style.transform = "", a.style.position = "", a.style.left = "", a.style.top = "");
    }, k = ee(() => {
      const a = !!t.position || t.dragging, i = t.position || t.defaultPosition;
      return {
        // Set left if horizontal drag is enabled
        x: qe(t.axis) && v(a) ? t.currentPosition.x : v(i).x,
        // Set top if vertical drag is enabled
        y: Ke(t.axis) && v(a) ? t.currentPosition.y : v(i).y
      };
    }), F = (a = !1) => {
      const i = v(n);
      if (i && (a || t.update && t.dragging)) {
        t.enableTransformFix && U();
        const f = t.positionOffset, l = t.isElementSVG, p = !l && Re(v(k), f) || !1, E = l && Ve(v(k), f) || !1;
        if (typeof E == "string" && i.setAttribute("transform", E), p)
          for (const $ of Object.keys(p))
            $ === "transform" && (p[$] += `${i.style[$]}`.replace(/translate\((-?\d+?.{0,2},? ?)+\)+/gm, "").trim()), i.style[$] = p[$];
        const M = {
          el: v(n),
          style: p,
          transform: E,
          classes: u.value
        };
        g.trigger(M);
      }
    }, u = ee(() => ({
      [t.defaultClassName]: !t.disabled,
      [t.defaultClassNameDragging]: t.dragging,
      [t.defaultClassNameDragged]: t.dragged
    })), y = () => Object.keys(v(u)).forEach((a) => {
      var i, f;
      v(u)[a] ? (i = v(n)) == null || i.classList.toggle(a, !0) : (f = v(n)) == null || f.classList.toggle(a, !1);
    });
    O(u, y);
    const { onDragStart: S, onDrag: P, onDragStop: C } = Z(e, r, !0);
    P(({ event: a, data: i }) => x(a, i)), S(({ event: a, data: i }) => m(a, i)), C(({ event: a, data: i }) => D(a, i));
    const w = (a = !1) => {
      const i = t.position;
      j("Draggable: Updated %j", {
        position: t.currentPosition,
        prevPropsPosition: t.prevPropsPosition
      }), i && (t.currentPosition = i, t.prevPropsPosition = { ...i }), t.enableTransformFix ? T() : F(a);
    };
    Me(() => {
      t.dragging = !1;
    }), K(() => {
      var E;
      if (n.value = Q(e), !n) {
        console.error("You are trying to use <Draggable> without passing a valid target reference.");
        return;
      }
      let a = 0, i = 0;
      const f = t.position, l = t.defaultPosition, p = (E = v(n)) == null ? void 0 : E.style;
      f && typeof f.x < "u" ? a = f.x : l && typeof l.x < "u" ? a = l.x : p && p.top && (a = b(p.top)), f && typeof f.y < "u" ? i = f.y : l && typeof l.y < "u" ? i = l.y : p && p.left && (i = b(p.left)), t.currentPosition = { x: a, y: i }, y(), w(!0), O(
        () => t.position,
        (M) => {
          let $ = !1;
          ((M == null ? void 0 : M.x) !== t.currentPosition.x || M.y !== t.currentPosition.y) && ($ = !0), w($);
        }
      );
    });
  }), {
    ...ie(t),
    state: t,
    onDragStart: s.on,
    onDrag: c.on,
    onDragStop: h.on,
    onTransformed: g.on
  };
}
const Ze = (e, o) => {
  const n = q(), r = (n == null ? void 0 : n.emit) ?? ((t, s) => {
    const c = new CustomEvent(t, { detail: s });
    e.dispatchEvent(c);
  });
  if (o.arg === "core") {
    const { onDrag: t, onDragStop: s, onDragStart: c, state: h } = Z(e, o.value);
    t((g) => {
      r("move", g);
    }), c((g) => {
      r("start", g);
    }), s((g) => {
      r("stop", g);
    }), e["revue-draggable"] = h;
  } else {
    const { onDrag: t, onDragStop: s, onDragStart: c, onTransformed: h, state: g } = he(e, o.value);
    t((d) => {
      r("move", d);
    }), c((d) => {
      r("start", d);
    }), s((d) => {
      r("stop", d);
    }), h((d) => {
      r("transformed", d);
    }), e["revue-draggable"] = g;
  }
}, et = (e, o) => {
  const n = e;
  if (typeof n["revue-draggable"] < "u" && o.value && JSON.stringify(o.value) !== JSON.stringify(o.oldValue)) {
    const r = n["revue-draggable"];
    Object.assign(r, o.value);
  }
}, tt = {
  [X ? "mounted" : "inserted"]: Ze,
  [X ? "beforeUpdate" : "update"]: et
}, nt = tt, ot = ue({
  name: "Draggable",
  props: {
    axis: {
      type: String,
      default: "both"
    },
    bounds: {
      type: [Object, String, Boolean],
      default: !1
    },
    defaultClassName: {
      type: String,
      default: "revue-draggable"
    },
    defaultClassNameDragging: {
      type: String,
      default: "revue-draggable-dragging"
    },
    defaultClassNameDragged: {
      type: String,
      default: "revue-draggable-dragged"
    },
    defaultPosition: {
      type: Object,
      default: () => ({ x: 0, y: 0 })
    },
    scale: {
      type: Number,
      default: 1
    },
    position: {
      type: Object,
      default: void 0
    },
    positionOffset: {
      type: Object,
      default: void 0
    },
    allowAnyClick: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    enableUserSelectHack: {
      type: Boolean,
      default: !0
    },
    enableTransformFix: {
      type: [Boolean, Object],
      default: !1
    },
    cancel: {
      type: String,
      default: void 0
    },
    offsetParent: {
      type: Object,
      default: () => {
      }
    },
    grid: {
      type: Array,
      default: void 0
    },
    handle: {
      type: String,
      default: void 0
    },
    update: {
      type: Boolean,
      default: !0
    },
    start: {
      type: Function,
      default: () => {
      }
    },
    move: {
      type: Function,
      default: () => {
      }
    },
    stop: {
      type: Function,
      default: () => {
      }
    },
    mouseDown: {
      type: Function,
      default: () => {
      }
    }
  },
  emits: ["move", "start", "stop", "transformed"],
  setup(e, { slots: o, emit: n, attrs: r }) {
    const t = ge("target", null), { onDrag: s, onDragStart: c, onDragStop: h, onTransformed: g, state: d } = he(t, e);
    return s((m) => n("move", m)), c((m) => n("start", m)), h((m) => n("stop", m)), g((m) => n("transformed", m)), O(
      () => e,
      (m) => Object.assign(d, m),
      { deep: !0, flush: "post" }
    ), X ? () => {
      if (o.default)
        return R(
          o.default({
            state: d
          })[0],
          { ref: "target", ...r },
          {}
        );
    } : () => {
      if (o.default)
        return R("div", { ref: "target", ...r }, o.default({ state: d }));
    };
  }
}), rt = ot, at = ue({
  name: "DraggableCore",
  props: {
    scale: {
      type: Number,
      default: 1
    },
    allowAnyClick: {
      type: Boolean,
      default: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    enableUserSelectHack: {
      type: Boolean,
      default: !0
    },
    cancel: {
      type: String,
      default: void 0
    },
    offsetParent: {
      type: Object,
      default: void 0
    },
    grid: {
      type: Array,
      default: void 0
    },
    handle: {
      type: String,
      default: void 0
    },
    onStart: {
      type: Function,
      default: () => {
      }
    },
    onMove: {
      type: Function,
      default: () => {
      }
    },
    onStop: {
      type: Function,
      default: () => {
      }
    },
    onMouseDown: {
      type: Function,
      default: () => {
      }
    }
  },
  emits: ["start", "move", "stop"],
  setup(e, { slots: o, emit: n, attrs: r }) {
    const t = ge("core-target", null), { onDrag: s, onDragStart: c, onDragStop: h, state: g } = Z(t, e);
    return s((d) => n("move", d)), c((d) => n("start", d)), h((d) => n("stop", d)), O(
      () => e,
      (d) => Object.assign(g, d),
      { deep: !0, flush: "post" }
    ), X ? () => {
      if (o.default)
        return R(o.default()[0], { ref: "core-target", ...r }, {});
    } : () => {
      if (o.default)
        return R("div", { ref: "core-target", ...r }, o.default());
    };
  }
}), st = at, it = (e) => {
  e.component("Draggable", rt), e.component("DraggableCore", st), e.directive("draggable", nt);
}, lt = it;
export {
  rt as Draggable,
  st as DraggableCore,
  nt as DraggableDirective,
  lt as DraggablePlugin,
  he as useDraggable,
  Z as useDraggableCore
};
